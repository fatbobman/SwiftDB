//
// Copyright (c) Vatsal Manot
//

import Compute
import CorePersistence
import Foundation
import Swallow

extension _Schema {
    public final class Entity: _Schema.Record, @unchecked Sendable {
        public var parent: _Schema.Entity.ID?
        public var typeIdentity: PersistableTypeIdentity
        public var subentities: [_Schema.Entity]
        public var properties: [_Schema.Entity.Property]
        
        public init(
            parent: _Schema.Entity.ID?,
            name: String,
            typeIdentity: PersistableTypeIdentity,
            subentities: [_Schema.Entity],
            properties: [_Schema.Entity.Property]
        ) {
            self.parent = parent
            self.typeIdentity = typeIdentity
            self.subentities = subentities.sorted(by: \.name)
            self.properties = properties.sorted(by: \.name)
            
            super.init(type: .entity, name: name)
        }
        
        public required init(from decoder: Decoder) throws {
            let container = try decoder.polymorphic().container(keyedBy: CodingKeys.self)
            
            self.parent = try container.decode(forKey: .parent)
            self.typeIdentity = try container.decode(forKey: .typeIdentity)
            self.subentities = try container.decode(forKey: .subentities)
            self.properties = try container.decode(forKey: .properties)
            
            try super.init(from: decoder)
        }
        
        public override func encode(to encoder: Encoder) throws {
            try super.encode(to: encoder)
            
            var container = encoder.container(keyedBy: CodingKeys.self)
            
            try container.encode(parent, forKey: .parent)
            try container.encode(name, forKey: .name)
            try container.encode(typeIdentity, forKey: .typeIdentity)
            try container.encode(subentities, forKey: .subentities)
            try container.encode(properties, forKey: .properties)
        }
        
        public override func hash(into hasher: inout Hasher) {
            super.hash(into: &hasher)
            
            hasher.combine(parent)
            hasher.combine(name)
            hasher.combine(typeIdentity)
            hasher.combine(subentities)
            hasher.combine(properties)
        }
    }
}

// MARK: - Extensions -

extension _Schema.Entity {
    private enum CodingKeys: String, CodingKey {
        case parent
        case name
        case typeIdentity
        case subentities
        case properties
    }
}

extension _Schema.Entity {
    public var attributes: [_Schema.Entity.Attribute] {
        properties.compactMap({ $0 as? _Schema.Entity.Attribute })
    }
    
    public var relationships: [_Schema.Entity.Relationship] {
        properties.compactMap({ $0 as? _Schema.Entity.Relationship })
    }
}

// MARK: - Conformances -

extension _Schema.Entity: Identifiable {
    public enum ID: Codable, Hashable, Sendable {
        case autogenerated(String)
        case persistentTypeIdentifier(String)
        case unavailable
        
        public init(from entityType: _opaque_Entity.Type) throws {
            self = .autogenerated(String(describing: entityType))
        }
    }
    
    public var id: ID {
        .autogenerated(name)
    }
}

extension _Schema.Entity: KeyedValuesOfConstructible {
    public convenience init(from values: KeyedValuesOf<_Schema.Entity>) throws {
        self.init(
            parent: try values.value(for: \.parent),
            name: try values.value(for: \.name),
            typeIdentity: try values.value(for: \.typeIdentity),
            subentities: try values.value(for: \.subentities),
            properties: try values.value(for: \.properties)
        )
    }
}
