//
// Copyright (c) Vatsal Manot
//

import Compute
import CorePersistence
import Foundation
import Swallow

extension DatabaseSchema {
    public struct Entity: @unchecked Sendable, KeyedValuesOfConstructible {
        public var parent: DatabaseSchema.Entity.ID?
        public var name: String
        public var typeIdentity: PersistableTypeIdentity
        public var subentities: [DatabaseSchema.Entity]
        public var properties: [DatabaseSchema.Entity.Property]
        
        public init(
            parent: DatabaseSchema.Entity.ID?,
            name: String,
            typeIdentity: PersistableTypeIdentity,
            subentities: [DatabaseSchema.Entity],
            properties: [DatabaseSchema.Entity.Property]
        ) {
            self.parent = parent
            self.name = name
            self.typeIdentity = typeIdentity
            self.subentities = subentities.sorted(by: \.name)
            self.properties = properties.sorted(by: \.name)
        }
        
        public init(from values: KeyedValuesOf<DatabaseSchema.Entity>) throws {
            self.init(
                parent: try values.value(for: \.parent),
                name: try values.value(for: \.name),
                typeIdentity: try values.value(for: \.typeIdentity),
                subentities: try values.value(for: \.subentities),
                properties: try values.value(for: \.properties)
            )
        }
    }
}

// MARK: - Extensions -

extension DatabaseSchema.Entity: Codable {
    public enum CodingKeys: String, CodingKey {
        case parent
        case name
        case typeIdentity
        case subentities
        case properties
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.polymorphic().container(keyedBy: CodingKeys.self)
        
        self.parent = try container.decode(forKey: .parent)
        self.name = try container.decode(forKey: .name)
        self.typeIdentity = try container.decode(forKey: .typeIdentity)
        self.subentities = try container.decode(forKey: .subentities)
        self.properties = try container.decode(forKey: .properties)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(parent, forKey: .parent)
        try container.encode(name, forKey: .name)
        try container.encode(typeIdentity, forKey: .typeIdentity)
        try container.encode(subentities, forKey: .subentities)
        try container.encode(properties, forKey: .properties)
    }
}

extension DatabaseSchema.Entity {
    public var attributes: [DatabaseSchema.Entity.Attribute] {
        properties.compactMap({ $0 as? DatabaseSchema.Entity.Attribute })
    }
    
    public var relationships: [DatabaseSchema.Entity.Relationship] {
        properties.compactMap({ $0 as? DatabaseSchema.Entity.Relationship })
    }
}

// MARK: - Conformances -

extension DatabaseSchema.Entity: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(parent)
        hasher.combine(name)
        hasher.combine(typeIdentity)
        hasher.combine(subentities)
        hasher.combine(properties)
    }
}

extension DatabaseSchema.Entity: Identifiable {
    public enum ID: Codable, Hashable, Sendable {
        case autogenerated(String)
        case persistentTypeIdentifier(String)
        case unavailable
        
        public init(from entityType: _opaque_Entity.Type) throws {
            self = .autogenerated(String(describing: entityType))
        }
    }
    
    public var id: ID {
        .autogenerated(name)
    }
}
